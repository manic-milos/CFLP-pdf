% !TEX encoding = UTF-8 Unicode

\documentclass[a4paper]{article}

\usepackage{color}
\usepackage{url}
\usepackage[T2A]{fontenc} % enable Cyrillic fonts
\usepackage[utf8]{inputenc} % make weird characters work
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{caption}


\lstnewenvironment{algorithm}[1][] %defines the algorithm listing environment
{   
    \refstepcounter{nalg} %increments algorithm number
    \captionsetup{labelformat=algocaption,labelsep=colon} %defines the caption setup for: it ises label format as the declared caption label above and makes label and caption text to be separated by a ':'
    \lstset{ %this is the stype
        frame=tB,
        numbers=left, 
        numberstyle=\tiny,
        basicstyle=\scriptsize, 
        keywordstyle=\color{black}\bfseries\em,
        keywords={,input, output, return, datatype, function, in, if, else, foreach, while, begin, end, procedure,repeat,until,for,do } %add the keywords you want, or load a language as Rubens explains in his comment above.
        numbers=left,
        xleftmargin=.04\textwidth,
        #1 % this is to add specific settings to an usage of this environment (for instnce, the caption and referable label)
    }
}
{}

\usepackage[english, serbian]{babel}
%\usepackage[english, serbianc]{babel} %ukljuciti babel sa ovim opcijama, umesto gornjim, ukoliko se koristi cirilica

\usepackage[unicode]{hyperref}
\hypersetup{colorlinks, citecolor=green, filecolor=green, linkcolor=blue, urlcolor=blue}

%\newtheorem{primer}{Пример}[section] %ćirilični primer
\newtheorem{primer}{Primer}[section]
\newcounter{nalg}[subsection] % defines algorithm counter for chapter-level
\renewcommand{\thenalg}{\thechapter .\arabic{nalg}} %defines appearance of the algorithm counter
\DeclareCaptionLabelFormat{algocaption}{Algorithm \thenalg} % defines a new caption label as Algorithm x.y

\begin{document}

\title{Hard capacitated k-facility location problem \\ \small{Seminarski rad u okviru kursa\\
Matematičko programiranje i optimizacija\\ Matematički fakultet}}

\author{
Student:Miloš Manić 1087/2014\\
Problem br:14\\
Metode: Genetski algoritmi, iterativna lokalna pretraga i njihova hibridizacija}
\date{9.~april 2015.}
\maketitle

\abstract{


}


\tableofcontents

\newpage

\section{Problem}


Za Capacitated k-facility location problem(CKFL) dat je skup klijenata $D$ i skup potencijalnih postrojenja(lokacija na kojima se može izgraditi postrojenje $F$\cite{original}.
\begin{enumerate}[a)]
\item Svako postrojenje $i \in F$ ima kapacitet $s_i$
\item Izgradnja postrojenja $i \in F$ košta $f_i$
\item Svaki klijent $j \in D$ ima potražnju $d_i$
\item Slanje $x_{ij}$ jedinica robe od postrojenja $i$ do klijenta $j$ košta $c_{ij}x_{ij}$, gde je $c_{ij}$ jedinicna cena proporcionalna rastojanju između $i$ i $j$
\item Na svakoj potencijalnoj lokaciji $i \in F$ može se izgraditi najviše jedno postrojenje
\item Bez gubitka opštosti može se smatrati da su cene izgradnje $f_i$, kapaciteti $s_i$, i potražnje $d_j$ celi brojevi

\end{enumerate}
Cilj je opslužiti sve klijente koristeći najviše $k$ postrojenja sa što manjim(minimalnim) troškovima izgradnje postrojenja i dopremanja robe.

\subsection{Matematička formulacija problema}
CKFL se može formulisat kao sledeći Mixed Integer Problem(MIP) gde promenljiva $x_{ij}$ označava količinu potražnje klijenta $j$ koja je opslužena postrojenjem $i$, a $y_i$ označava da li je postrojenje $i$ otvorenoi\cite{original}:

\begin{align}
min \sum_{i \in F}\sum_{j \in D}c_{ij}x_{ij} + \sum_{j \in F}f_iy_i\\
 subject\: to: 
\quad \sum_{i \in F}x_{ij} = d_j, \forall j \in D,\quad\\
 \sum_{j \in D}x_{ij} \le s_iy_i, \forall i \in F,\\
\sum_{i \in F}y_i \le k,\\
x_{ij} \ge 0, \forall i \in F,\forall j \in D,\\
y \in \{ 0 , 1 \}, \forall i \in F
\end{align}

\subsection{Primena}

Kao što ime kaže ovakvi problemi se javljaju prilikom planiranja postavljanja postrojenja i prostornog planiranja.

Neke od primera primena obuhvataju\cite{tokyo}:
\begin{itemize}
\item  Optimizacija rasporeda zgrada u fabričkom postrojenju
\item Nalaženje rasporeda skladišta nekog prodajnog lanca
\item Planiranje lokacija bitnih gradskih ustanova(bolnice, vatrogasne stanice \ldots)
\item Planiranje lokacija baznih stanica za bežične mreže
\item Raspored elemenata na čipu radi optimalne jačine signala prilikom VLSI dizajna
\end{itemize}

\subsection{Postojeći načini rešavanja}

Pored korišćenja egzaktnih metoda kao što su metode linearnog programiranja, problem je rešavan raznim heuristikama. Neke od najkorišćenijih pristupa su\cite{Silva}:
\begin{itemize}
\item Lokalna pretraga i varijacije
\item Gramzive heuristike
\item Tabu pretraga
\item Genetski algoritmi
\end{itemize}


\section{Heuristike}
U radu će se primeniti jedna P-heuristika, genetski algoritam, jedna S-heuristika, iterativna lokalna pretraga, i jednu hibridna, genetski algoritam poboljšan iterativnom lokalnom pretragom na generacijskom nivou.
\subsection{Genetski algoritmi}
Genetski algoritam je metaheuristika inspirisana procesom prirodne selekcije koji pripada klasi evolucionih algoritama. Bazira se na operatorima koji su inspirisani prirodom kao što su mutacija, ukrštanje i selekcija\cite{mitchellbook}.


Genetski algoritam radi nad populacijom kandidata rešenja(jedinke, rešenja, fenotipi) koja imaju određene karakteristike koje se predstavljaju nekim kodiranjem(uobičajeno nizom nula i jedinica) koje se naziva genotip.\cite{whitley} Prilagođenost(\emph {eng. fitness}).

Opšti koraci u genetskom algoritmu su sledeći:

\begin{enumerate}

\item Inicijalizacija:\\ Generisanje početnih rešenja(jedinki) koje će se naknadno poboljšavati kroz algoritam,
\item Mutacija: \\ Menjanje jednog ili više nasumičnih vrednosti genotipa neke jedinke. Primeri:
\begin{itemize}
\item bit string mutacija: bitovi genotipa se nasumično menjaju sa određenom verovatnoćom na nasumičnim mestima
\item uniformna mutacija: menja se vrednost izabrane jedinke za novu nasumično generisanu jedinku
\item Swap mutacija: razmenjuju se vrednosti 2 proizvoljne lokacije
\item Scramble: nekoliko spojenih pozicija se permutuje
\end{itemize}
\item Selekcija: \\ Odabir određenih jedinki koje će učestvovati u ukrštanju. Prilagođenost, kao i u prirodi ima veliki uticaj na selekciju. Primeri:
\begin{itemize}
\item Rulet selekcija: Svaka jedinka dobije verovatnoću odabira proporcionalnu njenoj prilagođenosti
\item Rangovska selekcija: Svaka jedinka dobije verovatnoću odabira proporcionalnu njenom rangu prilagođenosti
\item Stohastičko univerzalno sampliranje: Svaka jedinka je jednako verovatno odabrana
\item Turnirska selekcija: Za svaku odabranu jedinku se održava turnir u kome pobeđuje najprilagođenija jedinka
\end{itemize}
\item Ukrštanje \\ Izabrane jedinke se ukrštaju tako što se kombinuju njihovi genotipi za dobijanje novih jedinki. Primeri:
\begin{itemize}
\item one-point ukrštanje: genomi dve jedinke se seku u jednoj tački i razmenjuju se sadržaji genome- levi deo prve jedinke sa levim druge i desni prve sa desnim druge
\item n-point ukrštanje: genotipi se seku u n tačaka i odgovarajući delovi se uzimaju za rezultujuću jedinku naizmenično
\item uniformno ukrštanje: za svaku poziciju u reprezentaciji se nasumično bira da li će da bude uzeta od jednog ili drugog roditelja
\end{itemize}
\item Prekid: \\ Proces se prekida kada je neki kriterijum prekida ispunjen. Neki od čestih kriterijuma:
\begin{itemize}
\item Fiksni broj generacija je dostignut,
\item Vrednost prilagođenosti je dostigla plato, i naredne iteracije ne daju bolje rezultate,
\item Neki drugi kriterijum je dostignut(dovoljno dobro rešenje je nađeno),
\item Resursi su istrošeni(memorija, vreme izvršavanja \ldots),
\item Ručni prekid
\end{itemize}
Obično se koristi neka kombinacija navedenih kriterijuma i drugih.
\end{enumerate}

 Koraci 2-4 se ponavljaju sve dok se ne ispuni neki kriterijum prekida.

\subsubsection{Prilagođeni genetski algoritam za rešavanje CFLP}

\subsection{Iterativna lokalna pretraga}

Iterativna lokalna pretraga(\emph{eng. iterated local search}) je heuristika koja generiše niz rešenja generisanih unutrašnjom heuristikom(neka varijanta lokalne pretrage), čime se dobijaju kvalitetnija rešenja od prostog ponavljanja te heuristike\cite{lourenccoils}. 
Proces se sastoji iz dva globalna koraka:
\begin{enumerate}
\item Perturbacija rešenja dobijenog lokalnom pretragom
\item Lokalna pretraga počev od modifikovanog rešenja
\end{enumerate}

Ovi koraci se ponavljaju sve dok se ne dostigne neki kriterijum zaustavljanja(fiksni broj iteracija, dostignut plato minimalne vrednosti \ldots)

Na kraju svake iteracije je izabrana jedna instanca između modifikovane i instance dobijene u prethodnoj iteraciji. Na osnovu kriterijuma prihvatanja instanci se formira putanja (\emph{eng. walk}) do izabranog najboljeg rešenja, neki od čestih izbora su:
\begin{itemize}
\item Better: Izabrati uvek bolje rešenje
\item Random: Izabrati uvek novo rešenje
\item Restart:Generisati novo rešenje ako se rešenje nije poboljšalo u prethodnih $n$ iteracija
\item Nasumično izabrati jedno od ponuđenih rešenja iz prethodnih $n$ iteracija.
\end{itemize}

Prva dva primera kriterijuma prihvatanja su određena samo trenutnim izborom i na njih ne utiču prethodne iteracije. Putanje koje se prave takvim kriterijumima se zovu Markovljeve putanje (\emph{eng. Markovian walks, Markovian chains}). Pošto poslednja dva primera uključuju u odluku prethodnih $n$ iteracija, oni ne prave Markovljeve putanje. 

Snaga i oblik perturbacije su takođe bitni i od njih zavisi uspešnost iterativne lokalne pretrage. Iterativna lokalna pretraga izbegava zadržavanje na istom lokalnom optimumu tako što primenjuje perturbacije. Snaga perturbacije treba biti dovoljna da ne možemo da se lokalnom pretragom vratimo na prethodno rešenje, dakle potrebno je izvršiti modifikaciju koja je većeg reda od lokalne pretrage. S druge strane, ako snaga perturbacije bude prevelika, iterativna lokalna pretraga se ponaša kao multistart pretraga(\emph{eng. Multistart local search}), pa se bolja rešenja nalaze sa manjom verovatnoćom. 

Neki od primera za perturbacije nad binarnom reprezentacijom rešenja:
\begin{itemize}
\item n-flip:Komplementiranje n nasumičnih bitova u reprezentaciji rešenja(U zavisnosti od lokalne pretrage, na primer
ako je prostor lokalne pretrage n-flip, tada perturbacija mora da bude bar n+1-flip)
\item n-switch: zamena vrednosti dva nasumična bita međusobno n puta
\item permutacija n nasumičnih bitova
\item \ldots
\end{itemize}

Takodje, perturbacije mogu biti adaptivne tako što se snaga perturbacije određuje na osnovu prethodnih rešenja, recimo, ako se rešenje nije poboljšalo nekoliko iteracija, povećava se snaga iteracije(recimo sa 2-flip na 3-flip).

Dakle, procedura iterativne lokalne pretrage na visokom nivou može se opisati na sledeći način:

\begin{algorithm}
procedure IteratedLocalSearch:
	s_0=GenerateInitialSolution;
	s*=LocalSearch(s_0);
	repeat:
		s'=Perturbation(s*,history);
		s*'=LocalSearch(s');
		s*=AcceptanceCriterion(s*,s*',history);
	until(termination condition met)
end
\end{algorithm}

Kriterijumi zaustavljanja mogu da budu bazirani na broju iteracija, vremenu ili nekom drugom resursu, platou minimalne vrednosti, itd.

\subsubsection{Prilagođena iterativna lokalna pretraga za rešavanje CFLP}
\subsection{Hibridizacija}

Genetski algoritmi i iterativna lokalna pretraga se mogu kombinovati na nekoliko načina. Jedan od njih je korišćenje genetskog algoritma za dobijanje populacije rešenja pa korišćenje iterativne lokalne pretrage za poboljšavanje tih rešenja. Drugi način je u poboljšavati deo svake generacije iterativnom lokalnom pretragom i ubacivati poboljšane jedinke u generaciju, takva varijacija genetskog algoritma se zove memetski algoritam(\emph{eng. Memetic algorithm})\cite{memetic}. U ovom radu su prikazani rezultati obe metode. U prvoj metodi se primenjivala iterativna lokalna pretraga na sve jedinke rezultujuće populacije genetskog algoritma. U memetskom algoritmu je zbog performansi izvršavana iterativna lokalna pretraga samo na prvih 10 jedinki, uz pamćenje vrednosti za jedinke koje se održe kroz generacije.
\section{Eksperimentalni rezultati}

Opisani metodi su implementirani u jeziku c\# i .NET okruženju. Za rad je korišćen Visual Studio Ultimate 2013. Za dobijanje egzaktnog rešenja korišćen je \emph{IBM ILOG CPLEX Teaching Edition 12.1}, čije je vreme izvršavanja po instanci ograničeno na 4 sata. Za testiranje je korišćen računar sa \emph{Intel i7} procesorom na $3.1GHz$ i $8GB \, RAM$ memorije. Aplikacija je izvršavana na jednom jezgru(bez paralelizacije) zato što strukture korišćene pri implementaciji nisu bile bezbedne za paralelni rad(\emph{thread-safe}).

Sve metode su sa svim instancama testirane po 20 puta sa različitim \emph{random seed} vrednostima. \emph{Random seed} vrednosti su dobijene pomoću drugog nasumičnog niza po sledećoj proceduri:

\begin{algorithm}
procedure testing(c):
	Random a=new Random(c);
	for 1 to 20 do:
		Random b=new Random(seed=a.next());
		test(random=b);
	end;
end.
\end{algorithm}

\subsection{Instance}
\subsection{Rezultati}
\subsection{Analiza rezultata}
\section{Zaključak}


\addcontentsline{toc}{section}{Literatura}
\appendix
\bibliography{seminarski} 
\bibliographystyle{plain}


\end{document}
